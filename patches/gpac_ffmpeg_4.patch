Description: Fix FTBFS with FFmpeg 4.0
Author: James Cowgill <jcowgill@debian.org>
Bug: https://github.com/gpac/gpac/pull/1063
Bug-Debian: https://bugs.debian.org/888343
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/applications/dashcast/video_encoder.c
+++ b/applications/dashcast/video_encoder.c
@@ -144,7 +144,7 @@ int dc_video_encoder_open(VideoOutputFil
 	}
 
 	//the global header gives access to the extradata (SPS/PPS)
-	video_output_file->codec_ctx->flags |= CODEC_FLAG_GLOBAL_HEADER;
+	video_output_file->codec_ctx->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
 
 	video_output_file->vstream_idx = 0;//video_stream->index;
 
--- a/modules/ffmpeg_in/ffmpeg_decode.c
+++ b/modules/ffmpeg_in/ffmpeg_decode.c
@@ -48,7 +48,7 @@
 static uint8_t * ffmpeg_realloc_buffer(uint8_t * oldBuffer, u32 size) {
 	uint8_t * buffer;
 	/* Size of buffer must be larger, see avcodec_decode_video2 documentation */
-	u32 allocatedSz = sizeof( char ) * (FF_INPUT_BUFFER_PADDING_SIZE + size);
+	u32 allocatedSz = sizeof( char ) * (AV_INPUT_BUFFER_PADDING_SIZE + size);
 	if (oldBuffer)
 		gf_free(oldBuffer);
 	buffer = gf_malloc( allocatedSz );
@@ -530,7 +530,7 @@ static GF_Err FFDEC_GetCapabilities(GF_B
 		capability->cap.valueInt = 1;
 		return GF_OK;
 	case GF_CODEC_PADDING_BYTES:
-		capability->cap.valueInt = FF_INPUT_BUFFER_PADDING_SIZE;
+		capability->cap.valueInt = AV_INPUT_BUFFER_PADDING_SIZE;
 		return GF_OK;
 	case GF_CODEC_REORDER:
 		capability->cap.valueInt = 1;
@@ -614,7 +614,7 @@ static GF_Err FFDEC_GetCapabilities(GF_B
 		break;
 
 	case GF_CODEC_PADDING_BYTES:
-		capability->cap.valueInt = FF_INPUT_BUFFER_PADDING_SIZE;
+		capability->cap.valueInt = AV_INPUT_BUFFER_PADDING_SIZE;
 		break;
 	default:
 		capability->cap.valueInt = 0;
--- a/modules/redirect_av/ffmpeg_ts_muxer.c
+++ b/modules/redirect_av/ffmpeg_ts_muxer.c
@@ -195,7 +195,7 @@ GF_AbstractTSMuxer * ts_amux_new(GF_AVRe
 		c->time_base.den = 1000;
 		// some formats want stream headers to be separate
 		if (ts->oc->oformat->flags & AVFMT_GLOBALHEADER)
-			c->flags |= CODEC_FLAG_GLOBAL_HEADER;
+			c->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
 	}
 #endif
 
@@ -230,7 +230,7 @@ GF_AbstractTSMuxer * ts_amux_new(GF_AVRe
 		}
 		// some formats want stream headers to be separate
 		if (ts->oc->oformat->flags & AVFMT_GLOBALHEADER)
-			c->flags |= CODEC_FLAG_GLOBAL_HEADER;
+			c->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
 
 	}
 	//av_set_pts_info(ts->audio_st, 33, 1, audioBitRateInBitsPerSec);
--- a/modules/redirect_av/redirect_av.c
+++ b/modules/redirect_av/redirect_av.c
@@ -128,7 +128,7 @@ static u32 audio_encoding_thread_run(voi
 	AVCodecContext * ctx = NULL;
 	assert( avr );
 
-	outBuffSize = FF_MIN_BUFFER_SIZE;
+	outBuffSize = AV_INPUT_BUFFER_MIN_SIZE;
 
 	outBuff = gf_malloc(outBuffSize* sizeof(u8));
 	inBuff = NULL;
